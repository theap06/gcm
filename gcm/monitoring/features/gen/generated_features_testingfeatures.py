# Copyright (c) Meta Platforms, Inc. and affiliates.
# All rights reserved.
#
# This file is autogenerated by the `bin/generate_features.py` script.
# To update:
# - Edit `gcm/features/feature_definitions/health_checks_features.py`
# - Run `python bin/generate_features.py`
# - Run `ufmt format gcm`

import logging
from pathlib import Path
from typing import Any, ClassVar, Dict, Optional

import tomli

logger = logging.getLogger(__name__)


class FeatureValueTestingFeatures:
    """This class reads features from an (optional) `config_path` file
    such as the `health_checks/config_example/feature_example.toml` file.
    To support dynamic updates, we load the config file on every check
    that is performed, so that the values of the config can change during
    runtime and affect the execution environment.
    """

    config_path: ClassVar[Optional[Path]]

    def load_config(self) -> Dict[str, Any]:
        if FeatureValueTestingFeatures.config_path is not None:
            try:
                with FeatureValueTestingFeatures.config_path.open("rb") as f:
                    features = tomli.load(f)
            except tomli.TOMLDecodeError as e:
                logger.exception(
                    f"Error reading toml file. {FeatureValueTestingFeatures.config_path} does not contain valid TOML. Error: {e}"
                )
                raise tomli.TOMLDecodeError(
                    f"{FeatureValueTestingFeatures.config_path} does not contain valid TOML.",
                ) from e
        else:
            raise ValueError(
                "The path for the config is not set. Please provide a config path argument."
            )

        return features

    def get_testingfeatures_flag1(self) -> bool:
        try:
            features = self.load_config()
        except Exception:
            return False
        value = features.get("TestingFeatures", {}).get("flag1", False)
        if not isinstance(value, bool):
            raise TypeError(
                f"Expected bool value for TestingFeatures.flag1, got {type(value).__name__} instead."
            )
        return value

    def get_testingfeatures_flag2(self) -> bool:
        try:
            features = self.load_config()
        except Exception:
            return False
        value = features.get("TestingFeatures", {}).get("flag2", False)
        if not isinstance(value, bool):
            raise TypeError(
                f"Expected bool value for TestingFeatures.flag2, got {type(value).__name__} instead."
            )
        return value

    def get_testingfeatures_constant1(self) -> int:
        try:
            features = self.load_config()
        except Exception:
            return -1
        value = features.get("TestingFeatures", {}).get("constant1", -1)
        if not isinstance(value, int):
            raise TypeError(
                f"Expected int value for TestingFeatures.constant1, got {type(value).__name__} instead."
            )
        return value

    def get_testingfeatures_constant2(self) -> int:
        try:
            features = self.load_config()
        except Exception:
            return -1
        value = features.get("TestingFeatures", {}).get("constant2", -1)
        if not isinstance(value, int):
            raise TypeError(
                f"Expected int value for TestingFeatures.constant2, got {type(value).__name__} instead."
            )
        return value
